/* 6 лабароторная работа 7 вариант
* Дана целочисленная матрица {Aij} i = 1...n; j = 1...n, n <= 100.
* Если все диагональные элемента матрицы являются нибильшими
* элементами своих строк, заменить элементы матрицы, содержащие
* цифру 0, на произведение диагональных элементов
*/
#include<iostream>
// Функция для проверки диагональных элементов матрицы.
// Если все диагональные элементы самые большие в своем ряду
// checkDiagonal возвращает true
bool checkDiagonal(int** arr, size_t size) {
	for (size_t i{}; i < size; ++i) {
		for (size_t j{}; j < size; ++j) {
			if (j == i) {
				// k - индекс для прохождения по элементам ряда
				for (size_t k{}; k < size; ++k) {
					// если выбранный элемент ряда больше диагонального и выбран НЕ диагональный элемент
					// возвращаем false и тем самым выходим из функции
					if (arr[i][k] >= arr[i][j] and j != k) {
						return false;
					}
				}
			}
		}
	}
	// если мы не вышли из функции с false, => все элементы наибольшие в своих строках и возвращаем true
	return true;
}
// функция для вывода матрицы в консоль
void showSquadMatrix(int** arr, size_t size) {
	// проходим по всем элементам матрицы
	for (size_t i{}; i < size; ++i) {
		for (size_t j{}; j < size; ++j) {
			// и выводим их на экран
			std::cout << "[" << arr[i][j] << "]  ";
		}
		std::cout << std::endl << std::endl;
	}
}
int main() {
	setlocale(LC_ALL, "ru");
	// получаем n для создания матрицы {Aij}, где i = 1...n; j = 1...n
	std::cout << "Введите число N: ";
	int n{};
	std::cin >> n;
	// Константа количества элементов в массиве для недиагональных элементов
	int const NON_DIAGONAL_LENGTH{ 10 };
	// Константа количества элементов в массив для диагональных элементов
	int const DIAGONAL_LENGTH{ 4 };
	// Размер и элементы массива выбраны не случайно, они позволяют с +- одной
	// вероятностью получать два вида матриц - где диагональные элементы 
	// наибольшие в строке и где диагональные элементы НЕ наибольшие в строке
	// Т. К. NON_DIAGONAL_LENGTH = 10 => массив заполняет оставшиеся 8 значений нулями
	int nonDiagonal[NON_DIAGONAL_LENGTH]{ 1, 2 };
	int diagonal[DIAGONAL_LENGTH]{ 2, 3, 4, 5 };
	// создание двумерного массива
	// int** cols - является одномерных массивом, элементы
	// которого также являются одномерными массивами
	int** cols = new int* [n];
	for (size_t i = 0; i < n; i++) {
		// заполняем элементы cols одномерными массивами
		cols[i] = new int[n];
	}
	// получаем уникальный seed генератора псевдо-рандомных чисел для каждого запуска программы
	srand(time(NULL));
	for (size_t i{}; i < n; ++i) {
		for (size_t j{}; j < n; ++j) {
			if (i == j) {
				// Заполняем диагональные элементы, значениями из необходимого массива
				cols[i][j] = diagonal[rand() % DIAGONAL_LENGTH];
			}
			else {
				// Заполняем недиагональные элементы, значениями из необходимого массива
				cols[i][j] = nonDiagonal[rand() % NON_DIAGONAL_LENGTH];
			}
		}
	}
	// отладка
	std::cout << "Оригинальная матрица:" << std::endl;
	// вызываем функция для вывода массива
	showSquadMatrix(cols, n);
	// вызываем функцию для проверки элементов матрицы
	// если все диагональные элементы матрицы наибольшие => заходим в блок if() {..}
	// иначе в else {...}
	if (checkDiagonal(cols, n)) {
		// переменная для хранения произведения диагональных элементов
		int diagonalMul{ cols[0][0] };
		for (size_t i{ 1 }; i < n; ++i) {
			for (size_t j{ 1 }; j < n; ++j) {
				if (i == j) {
					diagonalMul *= cols[i][j];
				}
			}
		}
		// Заменяем нулевые элементы двумерной матрицы на перемножение диагональных элементов
		for (size_t i{}; i < n; ++i) {
			for (size_t j{}; j < n; ++j) {
				if (cols[i][j] == 0) {
					cols[i][j] = diagonalMul;
				}
			}
		}
		std::cout << "Все диагональные элементы матрицы являются наибольшими!" << std::endl;
		showSquadMatrix(cols, n);
	}
	else {
		std::cout << "Не все диагональные элементы матрицы являются наибольшими." << std::endl;
	}

}