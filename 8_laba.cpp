//8 лабораторная работа 7 вариант
//Дано целое число типа int, выведите на экран содержимое каждого из его байтов, используя знания по указателям. Дайте обоснование полученному результату.//
#include <iostream>
#include <string>
#include <cstdio>
// функция для получения битов из 1 байта
std::string getBinnary(unsigned char n) {
	std::string buff{};
	while (n > 0) {
		buff += std::to_string(n % 2);
		n /= 2;
	}
	return std::string(buff.crbegin(), buff.crend());
}
int main() {
	setlocale(LC_ALL, "ru");
	std::cout << "Введите число типа int: ";
	int value{};
	std::cin >> value;
	// конструкция для получения 1ого из 4рёх байт числа int, для 64 разрядных систем
	// в 32 разрядных систем int содержит 2 байта
	// unsigned char - тип данных размером в 1 байт => получая адрес от int
	// в value_p помещается только первый байт, а остальные отсекаются
	unsigned char* value_p{ ((unsigned char*)&value) };
	// используя арифметику указателей (++value_p - которая
	// увеличивает адрес на резмер типа данных [в нашем случае на 1])
	// до тех пор, пока мы не пройдемся по всем байтам типа int (как указано в задании)
	for (size_t i{}; i < sizeof(int); ++i, ++value_p) {
		// получаем строку с iным байтом в виде битов
		std::string binValue{ getBinnary(*value_p) };
		// printf - способ форматированного вывода, для языка C, рекомендуется НЕ использовать
		// однако, по неизвестной причине, стандартный поток вывода cout выводит адрес value_p
		// в некорректном виде
		// %p - спецификатор для вывода адреса
		// %s - спецификатор для вывода строки в стиле C (ссылки на массив из char с '\0' в конце)
		// реализация строк std::string позволяет получить строку в старом формате C посредством
		// метода c_str()
		printf("%p: %s\n", value_p, binValue.c_str());
	}
}